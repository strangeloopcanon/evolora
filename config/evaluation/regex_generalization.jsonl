{"task_id": "recog_2023-01-01_240000", "prompt": "Given this regex for matching timestamps:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nDoes it match \"2023-01-01 24:00:00\"? Answer yes or no, and briefly explain why.", "capability": "recognition", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [], "expected_answer": "no", "metadata": {"reason": "Invalid hour 24", "test_string": "2023-01-01 24:00:00"}}
{"task_id": "recog_2023-12-31_235959", "prompt": "Given this regex for matching timestamps:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nDoes it match \"2023-12-31 23:59:59\"? Answer yes or no, and briefly explain why.", "capability": "recognition", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [], "expected_answer": "yes", "metadata": {"reason": "Valid timestamp", "test_string": "2023-12-31 23:59:59"}}
{"task_id": "recog_2023-00-15_120000", "prompt": "Given this regex for matching timestamps:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nDoes it match \"2023-00-15 12:00:00\"? Answer yes or no, and briefly explain why.", "capability": "recognition", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [], "expected_answer": "no", "metadata": {"reason": "Invalid month 00", "test_string": "2023-00-15 12:00:00"}}
{"task_id": "recog_2023-01-01_126000", "prompt": "Given this regex for matching timestamps:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nDoes it match \"2023-01-01 12:60:00\"? Answer yes or no, and briefly explain why.", "capability": "recognition", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [], "expected_answer": "no", "metadata": {"reason": "Invalid minute 60", "test_string": "2023-01-01 12:60:00"}}
{"task_id": "synth_timestamp_basic", "prompt": "Match a valid log timestamp of the form YYYY-MM-DD HH:MM:SS with:\n- year: 2000\u20132099\n- month: 01\u201312\n- day: 01\u201331\n- 24-hour time (00:00:00 to 23:59:59)\n- exactly one space between date and time\n- no extra characters before or after\n\nWrite a regex pattern that matches valid timestamps. Respond with only the regex.", "capability": "synthesis", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [{"string": "2023-01-01 00:00:00", "should_match": true}, {"string": "2099-12-31 23:59:59", "should_match": true}, {"string": "2024-06-15 12:30:45", "should_match": true}, {"string": "2023-01-01 24:00:00", "should_match": false}, {"string": "2023-13-01 12:00:00", "should_match": false}, {"string": "2023-01-32 12:00:00", "should_match": false}, {"string": "1999-01-01 12:00:00", "should_match": false}, {"string": "2023-1-01 12:00:00", "should_match": false}, {"string": "2023-01-01  12:00:00", "should_match": false}, {"string": " 2023-01-01 12:00:00", "should_match": false}], "expected_answer": null, "metadata": {}}
{"task_id": "explain_timestamp", "prompt": "Explain what this regex matches in plain English:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "capability": "explanation", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [], "expected_answer": null, "metadata": {"required_keywords": ["year", "month", "day", "hour", "minute", "second", "2000", "2099", "timestamp"]}}
{"task_id": "debug_timestamp_0", "prompt": "This regex is supposed to match valid timestamps (Match a valid log timestamp of the form YYYY-MM-DD HH:MM:SS with:\n- year: 2000\u20132099\n- month: 01\u201312\n- day: 01\u201331\n- 24-hour time (00:00:00 to 23:59:59)\n- exactly one space between date and time\n- no extra characters before or after) but has a bug:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-4]):[0-5]\\d:[0-5]\\d$\n\nFix the regex. Respond with only the corrected pattern.", "capability": "debugging", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]) (?:[01]\\d|2[0-4]):[0-5]\\d:[0-5]\\d$", "test_cases": [{"string": "2023-01-01 00:00:00", "should_match": true}, {"string": "2099-12-31 23:59:59", "should_match": true}, {"string": "2024-06-15 12:30:45", "should_match": true}, {"string": "2023-01-01 24:00:00", "should_match": false}, {"string": "2023-13-01 12:00:00", "should_match": false}, {"string": "2023-01-32 12:00:00", "should_match": false}, {"string": "1999-01-01 12:00:00", "should_match": false}, {"string": "2023-1-01 12:00:00", "should_match": false}, {"string": "2023-01-01  12:00:00", "should_match": false}, {"string": " 2023-01-01 12:00:00", "should_match": false}], "expected_answer": null, "metadata": {"bug_description": "Allows hour 24"}}
{"task_id": "debug_timestamp_1", "prompt": "This regex is supposed to match valid timestamps (Match a valid log timestamp of the form YYYY-MM-DD HH:MM:SS with:\n- year: 2000\u20132099\n- month: 01\u201312\n- day: 01\u201331\n- 24-hour time (00:00:00 to 23:59:59)\n- exactly one space between date and time\n- no extra characters before or after) but has a bug:\n^(20\\d{2})-(\\d{2})-(\\d{2}) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nFix the regex. Respond with only the corrected pattern.", "capability": "debugging", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(\\d{2})-(\\d{2}) (?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [{"string": "2023-01-01 00:00:00", "should_match": true}, {"string": "2099-12-31 23:59:59", "should_match": true}, {"string": "2024-06-15 12:30:45", "should_match": true}, {"string": "2023-01-01 24:00:00", "should_match": false}, {"string": "2023-13-01 12:00:00", "should_match": false}, {"string": "2023-01-32 12:00:00", "should_match": false}, {"string": "1999-01-01 12:00:00", "should_match": false}, {"string": "2023-1-01 12:00:00", "should_match": false}, {"string": "2023-01-01  12:00:00", "should_match": false}, {"string": " 2023-01-01 12:00:00", "should_match": false}], "expected_answer": null, "metadata": {"bug_description": "Allows invalid months/days like 00 or 99"}}
{"task_id": "debug_timestamp_2", "prompt": "This regex is supposed to match valid timestamps (Match a valid log timestamp of the form YYYY-MM-DD HH:MM:SS with:\n- year: 2000\u20132099\n- month: 01\u201312\n- day: 01\u201331\n- 24-hour time (00:00:00 to 23:59:59)\n- exactly one space between date and time\n- no extra characters before or after) but has a bug:\n^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n\nFix the regex. Respond with only the corrected pattern.", "capability": "debugging", "holdout_type": null, "mutation_type": null, "target_regex": "^(20\\d{2})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [{"string": "2023-01-01 00:00:00", "should_match": true}, {"string": "2099-12-31 23:59:59", "should_match": true}, {"string": "2024-06-15 12:30:45", "should_match": true}, {"string": "2023-01-01 24:00:00", "should_match": false}, {"string": "2023-13-01 12:00:00", "should_match": false}, {"string": "2023-01-32 12:00:00", "should_match": false}, {"string": "1999-01-01 12:00:00", "should_match": false}, {"string": "2023-1-01 12:00:00", "should_match": false}, {"string": "2023-01-01  12:00:00", "should_match": false}, {"string": " 2023-01-01 12:00:00", "should_match": false}], "expected_answer": null, "metadata": {"bug_description": "Missing space between date and time"}}
{"task_id": "refactor_timestamp", "prompt": "Simplify this regex without changing its matching behavior:\n^(20[0-9][0-9])-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) ([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$\n\nRespond with only the simplified pattern.", "capability": "refactoring", "holdout_type": null, "mutation_type": null, "target_regex": "^(20[0-9][0-9])-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1]) ([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$", "test_cases": [{"string": "2023-01-01 00:00:00", "should_match": true}, {"string": "2099-12-31 23:59:59", "should_match": true}, {"string": "2024-06-15 12:30:45", "should_match": true}, {"string": "2023-01-01 24:00:00", "should_match": false}, {"string": "2023-13-01 12:00:00", "should_match": false}, {"string": "2023-01-32 12:00:00", "should_match": false}, {"string": "1999-01-01 12:00:00", "should_match": false}, {"string": "2023-1-01 12:00:00", "should_match": false}, {"string": "2023-01-01  12:00:00", "should_match": false}, {"string": " 2023-01-01 12:00:00", "should_match": false}], "expected_answer": null, "metadata": {}}
{"task_id": "holdout_operator_alternation", "prompt": "Write a regex to match either 'cat' or 'dog' as a complete word. Respond with only the regex.", "capability": "synthesis", "holdout_type": "operator", "mutation_type": null, "target_regex": null, "test_cases": [{"string": "cat", "should_match": true}, {"string": "dog", "should_match": true}, {"string": "cats", "should_match": false}, {"string": "hotdog", "should_match": false}, {"string": "catalog", "should_match": false}], "expected_answer": null, "metadata": {"held_out_concept": "alternation (|)"}}
{"task_id": "holdout_composition_mixed", "prompt": "Write a regex to match day numbers 01-31 where days 1-9 must have leading zero. Respond with only the regex.", "capability": "synthesis", "holdout_type": "composition", "mutation_type": null, "target_regex": null, "test_cases": [{"string": "01", "should_match": true}, {"string": "15", "should_match": true}, {"string": "31", "should_match": true}, {"string": "00", "should_match": false}, {"string": "32", "should_match": false}, {"string": "1", "should_match": false}, {"string": "9", "should_match": false}], "expected_answer": null, "metadata": {"held_out_concept": "alternation + character classes combined"}}
{"task_id": "holdout_semantic_datetime", "prompt": "Write a regex to match datetime strings in ISO 8601 format: YYYY-MM-DDTHH:MM:SS. Years should be 1900-2099, months 01-12, days 01-31, hours 00-23, minutes and seconds 00-59. Respond with only the regex.", "capability": "synthesis", "holdout_type": "semantic_coupling", "mutation_type": null, "target_regex": null, "test_cases": [{"string": "2023-06-15T14:30:00", "should_match": true}, {"string": "1999-12-31T23:59:59", "should_match": true}, {"string": "2023-13-01T12:00:00", "should_match": false}, {"string": "2023-06-15T25:00:00", "should_match": false}, {"string": "2023-06-15 14:30:00", "should_match": false}], "expected_answer": null, "metadata": {"held_out_concept": "joint date + time constraints"}}
{"task_id": "holdout_surface_delimiter", "prompt": "Write a regex to match dates in format YYYY.MM.DD (using dots as separators). Year 2000-2099, month 01-12, day 01-31. Respond with only the regex.", "capability": "synthesis", "holdout_type": "surface_form", "mutation_type": null, "target_regex": null, "test_cases": [{"string": "2023.06.15", "should_match": true}, {"string": "2000.01.01", "should_match": true}, {"string": "2023-06-15", "should_match": false}, {"string": "2023/06/15", "should_match": false}, {"string": "2023.13.01", "should_match": false}], "expected_answer": null, "metadata": {"held_out_concept": "delimiter variation (dot vs dash)"}}
{"task_id": "mutation_effect_0", "prompt": "Original regex: ^(?:[01]\\d|2[0-3]):[0-5]\\d$\nMutated regex: ^(?:[01]\\d|2\\d):[0-5]\\d$\n\nThe hour part was changed from '2[0-3]' to '2\\d'. What new strings will now match that didn't before?", "capability": "recognition", "holdout_type": null, "mutation_type": "widen_range", "target_regex": "^(?:[01]\\d|2[0-3]):[0-5]\\d$", "test_cases": [], "expected_answer": null, "metadata": {"mutated_regex": "^(?:[01]\\d|2\\d):[0-5]\\d$", "required_keywords": ["24", "25", "26", "27", "28", "29"]}}
{"task_id": "mutation_effect_1", "prompt": "Original regex: ^(?:0[1-9]|1[0-2])$\nMutated regex: ^0[1-9]|1[0-2]$\n\nThe non-capturing group was removed. How does the matching behavior change?", "capability": "recognition", "holdout_type": null, "mutation_type": "remove_grouping", "target_regex": "^(?:0[1-9]|1[0-2])$", "test_cases": [], "expected_answer": null, "metadata": {"mutated_regex": "^0[1-9]|1[0-2]$", "required_keywords": ["anchor", "beginning", "end", "partial", "alternation"]}}
{"task_id": "mutation_effect_2", "prompt": "Original regex: ^\\d{4}$\nMutated regex: ^\\d+$\n\nThe quantifier was changed from {4} to +. What new strings will now match?", "capability": "recognition", "holdout_type": null, "mutation_type": "change_quantifier", "target_regex": "^\\d{4}$", "test_cases": [], "expected_answer": null, "metadata": {"mutated_regex": "^\\d+$", "required_keywords": ["1", "12", "123", "12345", "any", "length"]}}
{"task_id": "mutation_repair_0", "prompt": "This regex was mutated and now allows hours 24-29:\n^(?:[01]\\d|2\\d):[0-5]\\d:[0-5]\\d$\n\nFix it to restore the original behavior. Respond with only the corrected regex.", "capability": "debugging", "holdout_type": null, "mutation_type": "widen_range", "target_regex": "^(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$", "test_cases": [{"string": "12:30:45", "should_match": true}, {"string": "23:59:59", "should_match": true}, {"string": "24:00:00", "should_match": false}, {"string": "29:30:00", "should_match": false}], "expected_answer": null, "metadata": {"broken_regex": "^(?:[01]\\d|2\\d):[0-5]\\d:[0-5]\\d$", "issue": "allows hours 24-29"}}
{"task_id": "mutation_repair_1", "prompt": "This regex was mutated and now matches partial strings:\n\\d{3}-\\d{4}\n\nFix it to restore the original behavior. Respond with only the corrected regex.", "capability": "debugging", "holdout_type": null, "mutation_type": "remove_anchor", "target_regex": "^\\d{3}-\\d{4}$", "test_cases": [{"string": "123-4567", "should_match": true}, {"string": "abc123-4567xyz", "should_match": false}, {"string": "123-4567890", "should_match": false}], "expected_answer": null, "metadata": {"broken_regex": "\\d{3}-\\d{4}", "issue": "matches partial strings"}}
